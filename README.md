# PLRE

A propositional logic reasoning engine, or propositional model checker.

# Overview

The PLRE (propositional logic reasoning engine) is a pure Python tool (package) for determining the truth values of propositional logic formulae, given a truth-value assignment (an assignment of truth values to the signature of, i.e. to the propositional symbols used in, the formulae).

The propositional logic formulae are expressed in text strings, in  [conjunctive normal form](https://en.wikipedia.org/wiki/Conjunctive_normal_form) (CNF), in a prepared text file.

At instantiation, the PLRE consumes a set of propositional symbols and the name of a text file containing propositional logic formulae (in CNF) that refer to those propositional symbols. The PLRE assumes one propositional formula per text file line. Each formula is parsed and validated. If valid, the formula is represented internally as an executable computational graph.

A truth-value assignment is an assignment of Boolean truth values, True or False, to the propositional symbols. A truth-value assignment can be thought of as representing one particular (or possible) world. The truth-value assignment *interprets* the propositional symbols. In first-order logic, the counterpart of a propositional truth-value assignment is called an **interpretation**. The source of the truth-value assignments is context-dependent; the PLRE does not know or care. For example, the truth-value assignments might correspond to sets of predictions generated by a neural network.

Given a truth-value assignment, the PLRE computes the truth values of each of the propositional formulae it consumed from the text file at instantiation. It reports those formulae that are *NOT* **satisfied** by the truth-value assignment (i.e. that resolve to Boolean truth value False). That is, the PLRE reports those formulae for which the truth-value assignment is *NOT* a **model**.

The PLRE also provides ancillary services, like displaying the computational graph of a specified formula, either before or after execution.

# Related work

## Automated reasoning

The PLRE contributes to the field of **automated reasoning**, in particular to the **model checking** dimension of its subfield **automated theorem proving**. Per Wikipedia, [model checking](https://en.wikipedia.org/wiki/Model_checking) problems are formulated as logic tasks that involve checking ``whether a structure satisfies a given logical formula''. The article then gives this example:
> **A simple model-checking problem consists of verifying whether a formula in the propositional logic is satisfied by a given structure.**

This is precisely what the PLRE does. So the PLRE can also be described as being a **propositional model checker**.  

[Note on terminalogy. The term 'structure' is used in Model Theory, a subfield of mathematical logic, in place of 'interpretation'. This allows Model Theory to use the term 'interpretation' for a different purpose --- i.e. to permit discussion of the notion of 'interpretations' of 'structures'. In the case of propositional logic, the term 'structure' corresponds to a truth-value assignment that interprets the propositional symbols.]


## Decision problems and decision procedures

Per Wikipedia, a [decision problem](https://en.wikipedia.org/wiki/Decision_problem) is a computational problem that can be framed as a question with a binary answer, **{yes, no}** or **{True, False}**, on some set of inputs. For example, consider the question: "given two numbers $x$ and $y$, does $x$ evenly divide $y$?". This is a decision problem. The **model checking** problem solved by the PLRE, of deciding whether a logical formula is **satisfied** by a structure (or interpretation, or propositional truth-value assignment) is also a **decision problem**.

Per the same Wikipedia article, a [decision procedure](https://en.wikipedia.org/wiki/Decision_problem) for a decision problem is an **algorithm** that can answer the question with respect to all inputs. For example, the algorithm of 'long division' is a **decision procedure** for the divisor decision problem just described. To perform the **model checking** task, the PLRE employs a strategy of representing a propositional logic formula as an executable computational graph, and then executing that graph, given a truth-value assignment. This PLRE **algorithm** for deciding whether a formula is **satisfied** or not is an example of a **decision procedure**.

## Computational logic

Per Wikipedia, [computational logic](https://en.wikipedia.org/wiki/Computational_logic) is basically alternate terminology for **automated reasoning** and **automated theorem proving**. It also has strong connections with **logic programming**.

The term **computational logic** was first used in 1970:
> Robinson et al., (1970).  Computational Logic - The Unification Computation. *Machine Intelligence 6*, 63-72, Edinburgh University Press, 1971.

In the 2nd paragraph of the paper, Robinson uses the term *computational logic*, and gives it a footnote explanation, saying:
> Surely a better phrase than 'theorem proving', for the branch of artificial intelligence which deals with how to make machines do deduction efficiently.

So Robinson defined **computational logic** broadly.

The journal [ACM Transactions on Computational Logic](https://dl.acm.org/journal/tocl) also defines the term *computational logic* broadly. The journal says it is 
> devoted to research concerned with **all uses of logic in computer science**. 

The PLRE fits these definitions of **computational logic**.


# Target use case

The target use case for the PLRE is as a symbolic reasoning component in neurosymbolic systems --- AI systems that blend symbolic reasoning with deep (subsymbolic) learning.

In particular, the PLRE is suitable for evaluating whether or not predictions of neural networks conform to (satisfy) logical requirements or constraints, such as the propositional logic requirements accompanying the annotated images in the ROAD-R dataset, per
> Giunchiglia et al., (2023). ROAD-R: The Autonomous Driving Dataset with Logical Requirements. *Machine Learning, 112*. https://doi.org/10.1007/s10994-023-06322-z


# Text-friendly logical operator symbols

The PLRE uses text-friendly symbols for logical operators to make it easy and intuitive to express propositional formulae, in CNF, in text files.

logical operator | conventional symbol | PLRE symbol 
--- | --- | --- | 
logical NOT | $\lnot$ | ! (exclamation mark)
logical OR  | $\lor$  | \| (vertical bar)
logical AND | $\land$ | & (ampersand)

Note: CNF does not permit shortcut propositional logical operators IMPLICATION ($\rightarrow$) or EQUIVALENCE ($\leftrightarrow$).


# Conjunctive normal form (CNF)

Per [Wikipedia](https://en.wikipedia.org/wiki/Conjunctive_normal_form), a CNF formula is a **conjunction** of one or more **clauses**, where each **clause** is a **disjunction** of one or more **literals**, and where a **literal** is a propositional symbol that may or may not be **negated**. Every propositional logic formula can be expressed in CNF. 

The PLRE permits parentheses around CNF clauses, but it does not rely upon them. In CNF, the logical AND operator, &, has special precedence as a clause separator. This is sufficient to allow the PLRE to parse formula in CNF correctly, even without parentheses. But users may well prefer to include parentheses for their own convenience.

Consider this set of propositional symbols: `{A, B, C, D, E, F, G, H}`

**Example formulae for these symbols in CNF with a single clause**

`A`

`!A`

`A | B | !C`

**Example formulae for these symbols in CNF with multiple clauses**

`A & B & !C`

`(A | B) & (C | !D)`

`(A | B | !C) & (!D | E | F) & (G | !H)`

# Example

Suppose a set of propositional symbols: `{A, B, C, D, E}`.

Suppose some propositional logic formulae:
1. `A | B | !C`
2. `(A | B) & (C | !D)`
3. `(A | B) & (C | !D) & E`

Suppose a particular truth-value assignment (or possible world, perhaps predicted by a deep learning model):
* the symbols explicitly assigned truth-value True are: $\{A, C\}$
* all other symbols are implicitly assigned truth-value False.

Given this truth-value assignment, the truth values of the three example formula computed by the PLRE would be as follows:

id | formula | computed truth value
--- | --- | --- |
1 | `A \| B \| !C` | True
2 | `(A \| B) & (C \| !D)` | True
3 | `(A \| B) & (C \| !D) & E` | False

The PLRE would report formula 3 as NOT being **satisfied** by the truth-value assignment (the possible world).


